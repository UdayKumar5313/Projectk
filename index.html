<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cybersecurity Password Generator</title>
  <style>
    /* Global Styles & Dark Hacker Theme */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(ellipse at center, #141414, #000);
      color: #e0e0e0;
      font-family: 'Courier New', Courier, monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    .container {
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #00adb5;
      border-radius: 10px;
      padding: 30px;
      width: 90%;
      max-width: 900px;
      box-shadow: 0 0 20px rgba(0, 173, 181, 0.5);
      overflow: hidden;
      position: relative;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 2em;
      color: #00adb5;
    }
    p.description {
      text-align: center;
      margin-bottom: 20px;
      font-style: italic;
      color: #a0a0a0;
    }
    #generateBtn {
      display: block;
      width: 250px;
      margin: 20px auto;
      padding: 15px;
      font-size: 1.2em;
      color: #fff;
      background-color: #00adb5;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: transform 0.2s, background-color 0.3s;
    }
    #generateBtn:hover {
      background-color: #01989a;
      transform: scale(1.05);
    }
    #generateBtn:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    #loader {
      margin: 20px auto;
      border: 6px solid #333;
      border-top: 6px solid #00adb5;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      display: none;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #output {
      background: #121212;
      padding: 15px;
      border-radius: 5px;
      max-height: 400px;
      overflow-y: auto;
      font-size: 0.9em;
      line-height: 1.4;
      margin-top: 20px;
      opacity: 0;
      transform: scale(0.95);
      transition: opacity 0.5s, transform 0.5s;
    }
    #output.visible {
      opacity: 1;
      transform: scale(1);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Cybersecurity Password Generator</h1>
    <p class="description">
      A cuttingâ€‘edge project loaded with 50 advanced cybersecurity features and flashy visuals!
    </p>
    <button id="generateBtn">Generate Password & Run Features</button>
    <div id="loader"></div>
    <div id="output"></div>
  </div>

  <script>
    // Utility: sleep returns a Promise that resolves after ms milliseconds.
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // AdvancedPasswordGenerator simulating 50 cybersecurity features
    class AdvancedPasswordGenerator {
      constructor(passwordLength = 16) {
        this.passwordLength = passwordLength;
        this.generatedPassword = this.generateRandomPassword();
        this.salt = this.generateSalt();
      }

      // Feature 1: Generate a base random password.
      generateRandomPassword() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[]{};:,.<>/?";
        let password = "";
        const randomValues = new Uint32Array(this.passwordLength);
        window.crypto.getRandomValues(randomValues);
        for (let i = 0; i < this.passwordLength; i++) {
          password += chars.charAt(randomValues[i] % chars.length);
        }
        return password;
      }

      // Feature 2: Check password strength (score out of 100).
      checkStrength(password) {
        let score = 0;
        if (password.length >= this.passwordLength) score += 20;
        if (/[a-z]/.test(password)) score += 20;
        if (/[A-Z]/.test(password)) score += 20;
        if (/[0-9]/.test(password)) score += 20;
        if (/[^A-Za-z0-9]/.test(password)) score += 20;
        return score;
      }

      // Feature 3: Compute SHA-256 hash asynchronously.
      async hashPassword(password) {
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
        const hashBuffer = await crypto.subtle.digest("SHA-256", data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      }

      // Feature 4: Encrypt password using AES-GCM (simulation).
      async encryptPassword(password) {
        const key = await crypto.subtle.generateKey(
          { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
        );
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encoded = new TextEncoder().encode(password);
        const encryptedBuffer = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, encoded);
        const encryptedArray = Array.from(new Uint8Array(encryptedBuffer));
        return {
          iv: iv.reduce((acc, byte) => acc + byte.toString(16).padStart(2, "0"), ""),
          ciphertext: encryptedArray.map(b => b.toString(16).padStart(2, "0")).join("")
        };
      }

      // Feature 5: Calculate Shannon entropy.
      computeEntropy(password) {
        const len = password.length;
        const freq = {};
        for (let c of password) { freq[c] = (freq[c] || 0) + 1; }
        let entropy = 0;
        for (let key in freq) {
          const p = freq[key] / len;
          entropy -= p * Math.log2(p);
        }
        return entropy.toFixed(2);
      }

      // Feature 6: Simulate breach detection.
      breachDetection(password) {
        const common = ["password", "123456", "admin", "qwerty"];
        return common.includes(password.toLowerCase());
      }

      // Feature 7: Generate a pseudo TOTP code.
      generateTOTP() {
        return String(Math.floor(Math.random() * 900000 + 100000));
      }

      // Feature 8: Log event with timestamp.
      logEvent(event) {
        return `${new Date().toISOString()} : ${event}`;
      }

      // Feature 9: Reverse and swap case.
      modifyPasswordLayers(password) {
        return password.split('').reverse().map(ch =>
          (ch === ch.toUpperCase() ? ch.toLowerCase() : ch.toUpperCase())
        ).join('');
      }

      // Feature 10: Insert a random special character.
      addSpecialChar(password) {
        const special = "!@#$%^&*()-_=+[]{};:,.<>/?";
        const idx = Math.floor(Math.random() * (password.length + 1));
        return password.slice(0, idx) + special.charAt(Math.floor(Math.random() * special.length)) + password.slice(idx);
      }

      // Feature 11: Append timestamp-based hash.
      timestampHash(password) {
        const combined = password + Date.now();
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
          hash = ((hash << 5) - hash) + combined.charCodeAt(i);
          hash |= 0;
        }
        return Math.abs(hash);
      }

      // Feature 12: Base64 encode.
      base64Encode(password) {
        return btoa(password);
      }

      // Feature 13: Generate simulated double salted hash.
      doubleSaltHash(password) {
        const salt2 = this.generateSalt();
        const combined = password + salt2;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
          hash = ((hash << 5) - hash) + combined.charCodeAt(i);
          hash |= 0;
        }
        return Math.abs(hash);
      }

      // Feature 14: Simulate SQL injection test.
      sqlInjectionTest(password) {
        const patterns = ["' OR '1'='1", "'; DROP TABLE", "\" OR \"\" = \""];
        return patterns.some(pattern => password.includes(pattern));
      }

      // Feature 15: Dictionary check.
      dictionaryCheck(password) {
        const words = ["hello", "password", "letmein"];
        return words.some(word => password.toLowerCase().includes(word));
      }

      // Feature 16: Buffer overflow simulation.
      bufferOverflowCheck(password) {
        return password.length > 100;
      }

      // Feature 17: Leetspeak conversion.
      leetspeakConversion(password) {
        const mapping = { a: '4', e: '3', i: '1', o: '0', s: '5', t: '7' };
        return password.split('').map(ch => mapping[ch.toLowerCase()] || ch).join('');
      }

      // Feature 18: Random delay.
      async randomDelay() {
        const delay = Math.random() * 400 + 100;
        await sleep(delay);
        return delay.toFixed(0);
      }

      // Feature 19: Simulate PBKDF2 key generation.
      pbkdf2Key(password) {
        let key = 0;
        const combined = password + this.salt;
        for (let i = 0; i < combined.length; i++) {
          key = ((key << 5) - key) + combined.charCodeAt(i);
          key |= 0;
        }
        return Math.abs(key);
      }

      // Feature 20: Check for repeating sequences.
      repeatingSequencesCheck(password) {
        for (let i = 1; i <= Math.floor(password.length / 2); i++) {
          const seq = password.substring(0, i);
          if (password.split(seq).length - 1 > 1) return true;
        }
        return false;
      }

      // Feature 21: Append random punctuation.
      improveEntropy(password) {
        const punctuation = "!@#$%^&*()-_=+[]{};:,.<>/?";
        let extra = "";
        for (let i = 0; i < 4; i++) {
          extra += punctuation.charAt(Math.floor(Math.random() * punctuation.length));
        }
        return password + extra;
      }

      // Feature 22: Generate a hacker-style tagline.
      generateTagline() {
        const taglines = [
          "Access Granted",
          "Override Complete",
          "System Breached",
          "Encryption Enabled",
          "Hack the Planet!"
        ];
        return taglines[Math.floor(Math.random() * taglines.length)];
      }

      // Feature 23: Simulate network latency (ms).
      networkLatencySimulation() {
        return Math.floor(Math.random() * 100 + 50);
      }

      // Feature 24: Debug log.
      debugLog(message) {
        return "DEBUG: " + message;
      }

      // Feature 25: Leaked password check.
      leakedPasswordCheck(password) {
        const leaked = ["123456", "password", "123456789", "qwerty"];
        return leaked.includes(password);
      }

      // Feature 26: Hexadecimal conversion.
      hexConversion(password) {
        return Array.from(password).map(ch => ch.charCodeAt(0).toString(16)).join('');
      }

      // Feature 27: Generate a random salt.
      generateSalt() {
        const arr = new Uint8Array(8);
        window.crypto.getRandomValues(arr);
        return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
      }

      // Feature 28: XOR obfuscation.
      xorObfuscation(password) {
        const key = Math.floor(Math.random() * 256);
        const obfuscated = Array.from(password).map(ch => String.fromCharCode(ch.charCodeAt(0) ^ key)).join('');
        return { obfuscated, key };
      }

      // Feature 29: Reverse string.
      reverseString(password) {
        return password.split('').reverse().join('');
      }

      // Feature 30: Mix two strings.
      mixPasswords(password1, password2) {
        let mixed = "";
        for (let i = 0; i < Math.min(password1.length, password2.length); i++) {
          mixed += password1[i] + password2[i];
        }
        return mixed;
      }

      // Feature 31: Append random numeric sequence.
      addNumericSequence(password) {
        let seq = "";
        for (let i = 0; i < 4; i++) {
          seq += Math.floor(Math.random() * 10);
        }
        return password + seq;
      }

      // Feature 32: ASCII shift.
      asciiShift(password) {
        const shift = Math.floor(Math.random() * 10) + 1;
        let shifted = "";
        for (let ch of password) {
          shifted += String.fromCharCode((ch.charCodeAt(0) + shift) % 128);
        }
        return { shifted, shift };
      }

      // Feature 33: Create ASCII art representation.
      asciiArt(password) {
        return `
+-------------------------------+
|  Password: ${password}  |
+-------------------------------+`;
      }

      // Feature 34: Secure deletion simulation.
      secureDelete() {
        return "Secure deletion simulated: memory cleared.";
      }

      // Feature 35: HMAC-like integrity simulation.
      hmacIntegrity(password) {
        const key = "secret";
        let combined = password + key;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
          hash = ((hash << 5) - hash) + combined.charCodeAt(i);
          hash |= 0;
        }
        return Math.abs(hash);
      }

      // Feature 36: Custom policy validation.
      customPolicyValidation(password) {
        if (password.length < this.passwordLength)
          return { valid: false, message: "Password too short" };
        if (!/[A-Z]/.test(password))
          return { valid: false, message: "Missing uppercase letter" };
        if (!/[0-9]/.test(password))
          return { valid: false, message: "Missing digit" };
        return { valid: true, message: "Password meets custom policy" };
      }

      // Feature 37: Firewall scan simulation.
      firewallScan(password) {
        return password.toLowerCase().includes("firewall") 
          ? "Alert: 'firewall' pattern detected!" 
          : "No issues detected";
      }

      // Feature 38: Caesar cipher.
      caesarCipher(password, shift = 3) {
        return password.split('').map(ch => {
          if (/[A-Za-z]/.test(ch)) {
            const base = ch === ch.toUpperCase() ? 65 : 97;
            return String.fromCharCode(((ch.charCodeAt(0) - base + shift) % 26) + base);
          }
          return ch;
        }).join('');
      }

      // Feature 39: Binary conversion.
      binaryConversion(password) {
        return Array.from(password)
          .map(ch => ch.charCodeAt(0).toString(2).padStart(8, '0'))
          .join(' ');
      }

      // Feature 40: Checksum (mod 256).
      checksum(password) {
        let sum = 0;
        for (let ch of password) {
          sum += ch.charCodeAt(0);
        }
        return sum % 256;
      }

      // Feature 41: Simulate user input delay.
      async userInputDelay() {
        const delay = Math.random() * 1500 + 500;
        await sleep(delay);
        return delay.toFixed(0);
      }

      // Feature 42: Hackerâ€‘style log.
      hackerLog(message) {
        return "[HACKER LOG] " + message;
      }

      // Feature 43: Scramble characters.
      scrambleCharacters(password) {
        const arr = password.split('');
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr.join('');
      }

      // Feature 44: Mirror string.
      mirrorString(password) {
        return password + password.split('').reverse().join('');
      }

      // Feature 45: Append system time.
      appendSystemTime(password) {
        return password + Date.now();
      }

      // Feature 46: ROT13 transformation.
      rot13Transformation(password) {
        return password.split('').map(ch => {
          const code = ch.charCodeAt(0);
          if (code >= 65 && code <= 90) {
            return String.fromCharCode(((code - 65 + 13) % 26) + 65);
          } else if (code >= 97 && code <= 122) {
            return String.fromCharCode(((code - 97 + 13) % 26) + 97);
          }
          return ch;
        }).join('');
      }

      // Feature 47: Code obfuscation (random case).
      codeObfuscation(password) {
        return password.split('').map(ch => Math.random() > 0.5 ? ch.toUpperCase() : ch.toLowerCase()).join('');
      }

      // Feature 48: Simulate digital signature.
      digitalSignature(password) {
        const data = password + "signature";
        let hash = 0;
        for (let i = 0; i < data.length; i++) {
          hash = ((hash << 5) - hash) + data.charCodeAt(i);
          hash |= 0;
        }
        return Math.abs(hash);
      }

      // Feature 49: Simulate multi-threading.
      async multithreadSimulation(password) {
        await sleep(100);
        return "Simulated multi-threading complete";
      }

      // Feature 50: Secure logging simulation.
      secureLogging(logMessage) {
        return "Logged: " + logMessage;
      }

      // Run all features sequentially (async) and return results.
      async runAllFeatures() {
        const results = {};
        const base = this.generatedPassword;
        results["Base Password"] = base;
        results["Strength Score"] = this.checkStrength(base);
        results["SHA-256 Hash"] = await this.hashPassword(base);
        results["Encrypted Password"] = await this.encryptPassword(base);
        results["Entropy"] = this.computeEntropy(base);
        results["Breach Detected"] = this.breachDetection(base);
        results["TOTP Code"] = this.generateTOTP();
        results["Log Event"] = this.logEvent("Password Generated");
        results["Modified Layers"] = this.modifyPasswordLayers(base);
        results["Special Char Added"] = this.addSpecialChar(base);
        results["Timestamp Hash"] = this.timestampHash(base);
        results["Base64 Encoding"] = this.base64Encode(base);
        results["Double Salt Hash"] = this.doubleSaltHash(base);
        results["SQL Injection Test"] = this.sqlInjectionTest(base);
        results["Dictionary Check"] = this.dictionaryCheck(base);
        results["Buffer Overflow Check"] = this.bufferOverflowCheck(base);
        results["Leetspeak Conversion"] = this.leetspeakConversion(base);
        results["Random Delay (ms)"] = await this.randomDelay();
        results["PBKDF2 Key"] = this.pbkdf2Key(base);
        results["Repeating Sequences"] = this.repeatingSequencesCheck(base);
        results["Improved Entropy"] = this.improveEntropy(base);
        results["Tagline"] = this.generateTagline();
        results["Network Latency (ms)"] = this.networkLatencySimulation();
        results["Debug Log"] = this.debugLog("Systems Nominal");
        results["Leaked Check"] = this.leakedPasswordCheck(base);
        results["Hex Conversion"] = this.hexConversion(base);
        results["New Salt"] = this.generateSalt();
        let { obfuscated, key } = this.xorObfuscation(base);
        results["XOR Obfuscation"] = obfuscated;
        results["XOR Key"] = key;
        results["Reversed String"] = this.reverseString(base);
        results["Mixed Passwords"] = this.mixPasswords(base, this.reverseString(base));
        results["Numeric Sequence"] = this.addNumericSequence(base);
        let { shifted, shift } = this.asciiShift(base);
        results["ASCII Shifted"] = shifted;
        results["Shift Value"] = shift;
        results["ASCII Art"] = this.asciiArt(base);
        results["Secure Delete"] = this.secureDelete();
        results["HMAC Integrity"] = this.hmacIntegrity(base);
        results["Custom Policy"] = this.customPolicyValidation(base).message;
        results["Firewall Scan"] = this.firewallScan(base);
        results["Caesar Cipher"] = this.caesarCipher(base);
        results["Binary Conversion"] = this.binaryConversion(base);
        results["Checksum"] = this.checksum(base);
        results["Input Delay (ms)"] = await this.userInputDelay();
        results["Hacker Log"] = this.hackerLog("Generation Complete");
        results["Scrambled"] = this.scrambleCharacters(base);
        results["Mirror String"] = this.mirrorString(base);
        results["Append Time"] = this.appendSystemTime(base);
        results["ROT13"] = this.rot13Transformation(base);
        results["Code Obfuscation"] = this.codeObfuscation(base);
        results["Digital Signature"] = this.digitalSignature(base);
        results["Multithread Simulation"] = await this.multithreadSimulation(base);
        results["Secure Logging"] = this.secureLogging("Executed all 50 features.");
        return results;
      }
    }

    // Visual interaction and UI flow
    async function generateAndDisplay() {
      const btn = document.getElementById("generateBtn");
      const loader = document.getElementById("loader");
      const output = document.getElementById("output");

      // Disable button and show loader animation.
      btn.disabled = true;
      output.classList.remove("visible");
      output.textContent = "";
      loader.style.display = "block";

      // Create an instance and run features.
      const generator = new AdvancedPasswordGenerator(16);
      const results = await generator.runAllFeatures();

      // Build a pretty output string.
      let displayText = "";
      for (const [feature, value] of Object.entries(results)) {
        displayText += feature + ":\n" + JSON.stringify(value, null, 2) + "\n\n";
      }

      // Hide loader and display results.
      loader.style.display = "none";
      output.textContent = displayText;
      output.classList.add("visible");

      // Re-enable button.
      btn.disabled = false;
    }

    // Attach event listener.
    document.getElementById("generateBtn").addEventListener("click", generateAndDisplay);
  </script>
</body>
</html>
